# Goose Project Standards (Ported from Claude Code)

This file provides project-specific standards and conventions for Goose recipes implementing Claude Code workflow utilities.

## Directory Protocols

### Topic-Based Structure
All workflow artifacts are organized in topic-based directories:
```
.claude/specs/{NNN_topic}/
  reports/     # Research analysis reports
  plans/       # Implementation plans (Level 0, Level 1, Level 2)
  summaries/   # Implementation and test summaries
  debug/       # Debug reports (committed to git)
  outputs/     # Generated artifacts
```

### Naming Convention
- Topic directories use numbered prefixes: `{NNN_topic_name}/`
- Semantic names generated by LLM-based topic-naming agent
- Reports: `{NNN}-{description}.md`
- Plans: `{NNN}-{description}-plan.md`

### Artifact Lifecycle
- Debug reports: Committed to version control
- Other artifacts: Gitignored (temporary working files)

## Plan Structure

### Plan Metadata (Required Fields)
Every plan MUST include these metadata fields at the top:
- **Date**: Creation date in YYYY-MM-DD format
- **Feature**: One-line description (50-100 chars)
- **Status**: [NOT STARTED] | [IN PROGRESS] | [COMPLETE] | [BLOCKED]
- **Estimated Hours**: Numeric range (e.g., "12-16 hours")
- **Standards File**: Absolute path to CLAUDE.md or .goosehints
- **Research Reports**: Markdown links to research reports or "none"

### Plan Levels
- **Level 0**: Single plan file with all phases
- **Level 1**: Phase expansion (phases/ subdirectory)
- **Level 2**: Stage expansion (phases/{NN}_phase/stages/ subdirectory)

### Phase Dependencies
Phases can declare dependencies for parallel execution:
```markdown
### Phase 2: Planning [NOT STARTED]
dependencies: [1]
```

### Phase Status Markers
- `[NOT STARTED]`: Phase not yet begun
- `[IN PROGRESS]`: Phase currently executing
- `[COMPLETE]`: Phase finished successfully
- `[BLOCKED]`: Phase cannot proceed

## Code Standards

### Recipe Structure
All recipes should follow this pattern:
1. **Metadata**: Description, parameters, sub_recipes
2. **Instructions**: Clear, imperative step-by-step guidelines
3. **Retry Checks**: Hard barrier validation for artifact creation
4. **Checkpoints**: State preservation for resumable workflows

### Hard Barrier Pattern
All artifact-creating subrecipes MUST use retry checks:
```yaml
retry:
  checks:
    - type: shell
      command: "test -f {{ artifact_path }} && test $(wc -c < {{ artifact_path }}) -gt 500"
      error_message: "Artifact not created or too small"
```

### MCP Server Design
- Use @anthropic-ai/mcp library
- Export tools with clear type signatures
- Handle errors gracefully with descriptive messages
- Return structured JSON responses

### Shell Commands
- Prefer absolute paths over relative paths
- Quote all file paths with spaces
- Use fail-fast error handling (set -euo pipefail)
- Suppress noise with 2>/dev/null where appropriate

## State Management

### Parameter Requirement Types

Goose recipes support three requirement types for parameters:

1. **required**: Parameter MUST be provided via --params on command line. Recipe fails with error if missing.
2. **optional**: Parameter is optional. Uses default value if not provided via --params.
3. **user_prompt**: If parameter provided via --params, use provided value. If NOT provided, interactively prompt user to enter value.

#### user_prompt Best Practices

Use user_prompt for:
- Primary user inputs (natural language descriptions, file paths)
- Configuration choices that require user decision
- Parameters without sensible defaults

Do NOT use user_prompt for:
- Subrecipe parameters (invoked programmatically, not by users)
- Parameters with sensible defaults (use optional instead)
- Internal state/context parameters

#### Interactive Prompting Examples

With user_prompt:
```bash
# Without --params: interactive prompt appears
$ goose run --recipe research.yaml
? Natural language description of research topic: _

# With --params: no prompt, uses provided value
$ goose run --recipe research.yaml --params topic="JWT authentication patterns"
```

**Backward Compatibility**: Recipes with user_prompt parameters maintain full backward compatibility. Existing scripts that provide parameters via --params continue to work unchanged.

### Recipe Parameters
Pass state between recipes using parameters:
```yaml
parameters:
  - key: plan_file
    input_type: string
    requirement: required
  - key: topic_path
    input_type: string
    requirement: required
```

### JSON State Files
For complex state, use JSON files in .goose/tmp/:
```bash
cat > .goose/tmp/state_{{ workflow_id }}.json <<EOF
{
  "plan_file": "{{ plan_file }}",
  "current_phase": {{ phase_num }},
  "iteration": {{ iteration }}
}
EOF
```

### Checkpoints
Use retry.checkpoint_file for resumable workflows:
```yaml
retry:
  checkpoint_file: ".goose/checkpoints/{{ workflow_id }}.json"
```

## Agent Behavioral Guidelines

### Research Specialist
When porting research-specialist.md to recipe instructions:
1. **STEP 1**: Verify report path exists
2. **STEP 2**: Create report file FIRST (Write tool)
3. **STEP 3**: Conduct research (Glob, Grep, Read tools)
4. **STEP 4**: Update report with findings (Edit tool)
5. **STEP 5**: Verify completion and return signal

### Plan Architect
When porting plan-architect.md to recipe instructions:
1. **STEP 1**: Analyze requirements (parse user description, review research)
2. **STEP 2**: Create plan file at exact path (Write tool)
3. **STEP 3**: Verify plan structure (metadata, phases, dependencies)
4. **STEP 4**: Return plan path confirmation signal

### Implementer Coordinator
When porting implementer-coordinator.md to recipe instructions:
1. Mark phase [IN PROGRESS] before execution
2. Execute phase tasks
3. Mark phase [COMPLETE] after execution
4. Create summary at context exhaustion or completion

## Testing Standards

### Integration Tests
- Test full workflow chains (research → plan → implement)
- Test edge cases (errors, retries, checkpoints)
- Test hard barrier enforcement
- Verify state persistence

### Performance Benchmarks
- Target <10% performance penalty vs Claude Code bash
- MCP server latency <100ms per tool call
- Recipe invocation overhead <500ms

### Test Organization
```
.goose/tests/
  integration/
    test-research-workflow.sh
    test-create-plan-workflow.sh
    test-implement-workflow.sh
  mcp-servers/
    test-plan-manager.js
    test-state-machine.js
```

## Documentation Standards

### Recipe Documentation
Each recipe should have:
- Clear description of purpose
- Parameter definitions with types and requirements
- Usage examples with sample commands
- Expected outputs and artifacts

### MCP Server Documentation
Each MCP server should document:
- Tool signatures with parameter types
- Return value structure
- Error conditions and messages
- Usage examples

### Migration Notes
Document differences from Claude Code:
- Architectural changes (bash blocks → YAML recipes)
- Translation patterns (Task tool → subrecipe)
- Known limitations and workarounds

## Error Handling

### Recipe Failures
- Use Goose native error handling
- Provide clear error messages
- Include troubleshooting hints
- Log errors to .goose/tmp/errors.jsonl

### MCP Server Errors
- Return structured error objects
- Include error type and context
- Suggest remediation steps
- Log to server logs

### Hard Barrier Failures
- Cleanup partial artifacts on failure
- Provide clear validation error messages
- Suggest corrective actions
- Prevent workflow continuation

## Workflow Orchestration

### Iteration Loops
For large plans requiring multiple iterations:
1. Use external orchestrator script (goose-implement-orchestrator.sh)
2. Pass iteration parameter to recipe
3. Check context exhaustion
4. Load continuation context between iterations
5. Break loop when requires_continuation=false

### Phase Execution
1. Mark phase [IN PROGRESS] (use plan-manager MCP)
2. Execute phase tasks
3. Verify phase completion
4. Mark phase [COMPLETE] (use plan-manager MCP)
5. Check all phases complete

### State Transitions
Valid workflow state transitions (use state-machine MCP):
- NOT_STARTED → RESEARCH
- RESEARCH → PLANNING
- PLANNING → IMPLEMENTATION
- IMPLEMENTATION → COMPLETE

## Clean-Break Development

### Internal Tooling Changes
When modifying Goose recipes or MCP servers:
- ALWAYS use clean-break refactoring
- No deprecation periods for internal tools
- Atomic migration, then delete old code
- Update documentation immediately

### Interface Changes
When changing recipe parameters or MCP tool signatures:
- Unified implementation (no compatibility wrappers)
- Update all callers atomically
- Document breaking changes prominently

## Known Limitations

### Goose vs Claude Code Differences
1. **Iteration Loops**: Goose lacks built-in iteration; requires external orchestrator
2. **State Persistence**: Must use JSON files or parameter passing (no bash state files)
3. **Hard Barriers**: Implemented via retry.checks (not bash verification blocks)
4. **Agent Delegation**: Uses subrecipe calls (not Task tool invocation)
5. **Library Functions**: Must be embedded or converted to MCP servers (no bash sourcing)

### Workarounds
- External iteration: Use goose-implement-orchestrator.sh script
- Complex state: Use plan-manager and state-machine MCP servers
- Bash utilities: Embed simple logic in instructions, convert complex to MCP

---

**Note**: This file is generated from Claude Code's CLAUDE.md and adapted for Goose ecosystem. For complete standards, see original Claude Code documentation at .claude/docs/
